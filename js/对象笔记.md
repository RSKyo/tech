# 关于对象的一些注意点
## 对象的创建

### 1. new Object()

```js
const a = new Object();
a.x = 1;

console.log(a); // { x: 1 }
console.log(Object.getPrototypeOf(a) === Object.prototype); // true
```
- 等价于 `{}`。
- 构造函数写法，几乎没人主动用。

### 2. 字面量 {}

```js
const b = {};
b.x = 1;

console.log(b); // { x: 1 }
console.log(Object.getPrototypeOf(b) === Object.prototype); // true
```
- 字面量语法，最常见、最简洁。
- 本质上和 `new Object()` 一样，继承 `Object.prototype`。

### 3. Object.fromEntries()

```js
const c = Object.fromEntries([["x", 1]]);
console.log(c); // { x: 1 }
console.log(Object.getPrototypeOf(c) === Object.prototype); // true
```
- 从 **键值对数组** 构造对象。
- 语法不同，结果还是一个继承 `Object.prototype` 的普通对象。

### 4. Object.create(Object.prototype)

```js
const d = Object.create(Object.prototype);
d.x = 1;

console.log(d); // { x: 1 }
console.log(Object.getPrototypeOf(d) === Object.prototype); // true
```
- 如果参数为 `Object.prototype` 则等价于 `{}`。
- 可以指定对象原型。

### 5. Object.create(null)

```js
const dict = Object.create(null);
dict.x = 1;

console.log(dict); // { x: 1 }
console.log(Object.getPrototypeOf(dict)); // null
console.log(dict.hasOwnProperty); // ❌ undefined
```
- 这是“纯净字典对象”，没有原型链。
- 不会被 `__proto__` 注入。
- 适合构造安全字典 / 极简容器。

### 6. Object.create(proto)

```js
const proto = { greet() { console.log("hi"); } };
const obj = Object.create(proto);

obj.x = 1;
obj.greet(); // "hi"
console.log(Object.getPrototypeOf(obj) === proto); // true
```
- 可以用来手动指定对象的原型。

### 总结
- `Object.create(Object.prototype)` ≈ `{}` ≈ `new Object()` ≈ `Object.fromEntries([...])` → 普通对象
- `Object.create(null)` → 纯净对象，没有任何原型方法
- `Object.create(proto)` → 原型是 `proto` 的对象
- 如果你目标是 **数据处理工具** → 用纯净对象（`{}` 或 `Object.create(null)`）更合适。
- 如果你目标是 **对象变换工具**（希望保留类实例感） → 保留原型。
- **实际应用里，90% 的库选择返回 `{}`**，因为直观、简单、不容易出错。

## 对象的属性

### 1. 属性有两种大类（互斥）

在 JavaScript 里，一个对象属性要么是：
- **数据属性 (Data Property)**
	- 关键字段：`value`、`writable`、`enumerable`、`configurable`
	- 能否修改 `value` → 取决于 `writable`
	- `writable:true` 时，可以赋值
	- `writable:false` 时，不能直接修赋值，但如果同时 `configurable:true` 可以变相通过 `Object.defineProperty(obj, k, { value: v })` 来修改值
	- 例子：`{ x: 1 }`
- **访问器属性 (Accessor Property)**
	- 关键字段：`get`、`set`、`enumerable`、`configurable`
	- 能否通过赋值语句修改值 → 取决于有没有 `set` 函数
	- 只要有 `set` 就能赋值
	- 例子：
```js
let _y = 0;
const obj = {
  get y() { return _y; },
  set y(val) { _y = val; }
};
```
注意：**二者是互斥的**，要么是数据属性，要么是访问器属性，绝不会同时拥有 `value`/`writable` 和 `get`/`set`。

### 2. `configurable` 能控制什么？

**a. `configurable:true` 时**
属性是可配置的，你可以随意切换它的“形态”：
- 数据属性 ↔ 访问器属性
- 改 flags
- 改成别的 value 或 getter/setter

例子：
```js
const obj = {};
Object.defineProperty(obj, "x", {
  get() { return 1; },
  configurable: true
});

// 可配置 ⇒ 可以把访问器改成数据属性
Object.defineProperty(obj, "x", {
  value: 42,
  writable: true
});
console.log(obj.x); // 42
```

**a. `configurable:false` 时**
属性是不可配置的，它的“形态”被**锁死**：
- 不能从数据属性改成访问器属性
- 也不能从访问器属性改成数据属性
- 也不能改 `enumerable` 或 `configurable`

例子：
```js
const obj = {};
Object.defineProperty(obj, "y", {
  get() { return 1; },
  configurable: false
});

// ❌ 试图把访问器属性改成数据属性
Object.defineProperty(obj, "y", {
  value: 42,
  writable: true
});
// TypeError: Cannot redefine property: y
```

### 总结

- `configurable:true` ⇒ 属性可以“换种类”（数据 <-> 访问器）。
- `configurable:false` ⇒ 属性种类被锁死，**访问器就永远是访问器，数据属性就永远是数据属性**。
- 对于 **不可配置的数据属性**：
    - 如果 `writable:true`，你仍然可以改 `value`。
    - 如果 `writable:false`，你连 `value` 也不能改。
- 对于 **不可配置的访问器属性**：
    - 你只能保留原来的 getter/setter，不可以替换掉它们。
    - 当然更不能改成数据属性。

## 对象属性的键

### 1. 键的分类

在 JavaScript 里，对象的**自有属性**可以分为两大类：
- **字符串键**
    - 最常见：`{ a: 1 }` → `"a"`
    - 即使你写的是数字 `obj[123] = "x"`，底层也会转成字符串 `"123"`
- **Symbol 键**
    - 通过 `Symbol()` 创建，独一无二，不会和字符串冲突
    - 常用于定义“私有”或“唯一”属性

每一类又分「可枚举 / 不可枚举」
- **可枚举**
    - 会出现在 `for...in`、`Object.keys`、`Object.entries`、`JSON.stringify` 这些“枚举”操作里
    - 默认 `{ a: 1 }` 里定义的属性就是可枚举的
- **不可枚举**
    - 不会出现在这些枚举结果里，但属性依然存在，可以直接访问
    - 内建方法（如 `Array.prototype.forEach`）一般是不可枚举的
    - 也可以自己用 `Object.defineProperty` 定义为不可枚举

### 2. 键的获取

- `Object.keys` → 自有 字符串（可枚举）
- `Object.getOwnPropertyNames` → 自有 字符串（可枚举、不可枚举）
- `Object.getOwnPropertySymbols` → 自有 symbol（可枚举、不可枚举）
- `Reflect.ownKeys` → 自有 字符串（可枚举、不可枚举）、symbol（可枚举、不可枚举）
- `for...in` → 自有 + 原型链 字符串（可枚举）
- `Object.entries` → 包含 自有 字符串（可枚举）的`[key, value]` 数组形式。

**示例**

获取 自有 symbol（可枚举）键：
```js
const keys = Object.getOwnPropertySymbols(obj).filter(k => Object.prototype.propertyIsEnumerable.call(obj, k))
```

获取 自有 字符串（可枚举）、symbol（可枚举）键：
```js
const keys = Reflect.ownKeys(obj).filter(k => Object.prototype.propertyIsEnumerable.call(obj, k))
```

获取 自有 + 原型链 字符串（可枚举）
```js
const parent = { a: 1 };
const child = Object.create(parent);
child.b = 2;

console.log(Object.keys(child));   
// ["b"]   ← 只枚举自有的可枚举字符串键

for (const k in child) {
  console.log(k);
}
// b
// a   ← 还会把原型链上的可枚举属性也拿到
```

**99% 场景** → `Object.keys(obj)` 就够了
- 只返回**自有的可枚举字符串属性**。
- 这是绝大多数场景下开发者所期待的「对象的键」。
- 与 `for...in` 不同，它不会枚举原型链上的属性。
- 与 `Reflect.ownKeys` 不同，它不会包含 `Symbol` 和不可枚举属性。

### 3. 可枚举性

**“可枚举 (enumerable)”** 其实是 对象属性的一个元数据标志，用来决定：这个属性会不会出现在 遍历/枚举 的结果里。

**a. 属性描述符里的 `enumerable`**

```js
const obj = {};
Object.defineProperty(obj, "a", {
  value: 1,
  enumerable: true
});
Object.defineProperty(obj, "b", {
  value: 2,
  enumerable: false
});

console.log(Object.getOwnPropertyDescriptor(obj, "a"));
// { value: 1, writable: false, enumerable: true, configurable: false }
```
- `a` → enumerable: true
- `b` → enumerable: false

**b. 可枚举 vs 不可枚举 的区别**

- **可枚举属性** 会出现在：
    - `for...in`
    - `Object.keys()`
    - `Object.entries()`
    - `JSON.stringify()`
- **不可枚举属性** 不会出现在这些结果里，但它依然存在，你直接访问是能读到的。

```js
console.log(Object.keys(obj)); // ["a"]
console.log(obj.a, obj.b);     // 1 2
```
所以“不可枚举”并不是“看不见”，而是“不会出现在常规遍历里”。

**c. `propertyIsEnumerable` 的用法**

`propertyIsEnumerable` 用来判断对象的键是否是可枚举的。
`propertyIsEnumerable` 是实例方法，它定义在 `Object.prototype` 上，需要一个具体对象作为 **this**：
```js
const obj = { a: 1 };
console.log(obj.propertyIsEnumerable("a")); // true
```
或者
```js
const obj = { a: 1 };
console.log(Object.prototype.propertyIsEnumerable.call(obj, "a")); // true
```

**为什么很多库喜欢用 `.call`？**
- 在工具函数里，不一定能保证 `obj` 本身有 `propertyIsEnumerable` 方法（比如 `Object.create(null)` 创建的纯净对象，就没有继承原型）。
- 用 `Object.prototype.propertyIsEnumerable.call(obj, k)` 可以确保无论 `obj` 有没有继承原型，都能工作。

### **总结**

- **可枚举** = 会出现在 `for...in` / `Object.keys` / `JSON.stringify` 等枚举结果里。
- **不可枚举** = 不会出现在枚举结果里，但依然存在，可以直接访问。
- 默认情况：通过字面量 `{ a: 1 }` 定义的属性是 **可枚举**；通过内建原型链（如 `Array.prototype.forEach`）或 `Object.defineProperty` 默认是 **不可枚举**。
- `Object.prototype.propertyIsEnumerable` 是个原型方法，必须有 `this`。
- `obj.propertyIsEnumerable(k)` 等价于 `Object.prototype.propertyIsEnumerable.call(obj, k)`。

## 对象的赋值

### 1. `__proto__` 特殊处理

`obj.__proto__ = something` 会触发 setter，修改对象的原型链（潜在原型污染漏洞）。
但 `Object.defineProperty(obj, "__proto__", { value: ... })` 会安全地把它当普通属性写进去。
```js

```
所以：**只有 `__proto__` 需要额外走 `defineProperty`，其他属性用 `obj[k] = v` 就好**。这样既安全，又保留了性能优势和原有属性特征。

### 2. 全部都用 `Object.defineProperty` 会怎样？

```js
function defineKV(obj, k, v) {
  Object.defineProperty(obj, k, {
    value: v,
    writable: true,
    enumerable: true,
    configurable: true,
  });
}
```
- **优点**
	- 不会触发 `__proto__` 的 setter，天然安全。
	- 任何键都能被安全地定义为数据属性。
- **缺点**
	- **性能稍慢**
		- `obj[k] = v` 是引擎层面最快的路径。
		- `Object.defineProperty` 每次都要构建描述符对象，慢得多。
		- 如果在热路径（循环里执行几千几万次），差距会明显。
	- **属性特征被重置**
		- 默认写法 `{ writable: true, enumerable: true, configurable: true }` 固定了属性描述符。
		- 如果对象本来就有这个属性，直接 `obj[k] = v` 会保留原本的 `writable/enumerable/configurable`；  
		  但 `defineProperty` 会**重新定义属性**，覆盖掉原有描述符。
		- 这可能改变对象的行为。

## 关于 prototype

### 1. 函数对象的 `.prototype` 属性

这是 **函数** 才有的特殊属性，用来作为 `new` 实例的原型。
```js
function Foo() {}
console.log(Foo.prototype); // { constructor: Foo }

const f = new Foo();
console.log(Object.getPrototypeOf(f) === Foo.prototype); // true
```
- 这里的 `.prototype` 是 **构造函数自带的属性**，只存在于函数上。

**普通对象是没有 `.prototype` 属性的**：
```js
const obj = {};
console.log(obj.prototype); // undefined
```

### 2. 对象的原型 (`[[Prototype]]`)

这是每个对象内部都维护的隐藏指针，指向它的原型对象。  
在 JS 里可以通过：
- `Object.getPrototypeOf(obj)`
- 或者（非标准）`obj.__proto__`
来访问。
```js
const obj = {};
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true
```

### 总结

- **函数.prototype** → 构造函数自带的属性，用来生成实例的原型。
- **对象的原型** → 每个对象内部隐藏的 `[[Prototype]]`，可通过 `Object.getPrototypeOf(obj)` 拿到。
- 普通对象没有 `.prototype` 属性！
- 只有函数才有 `.prototype`，它是用来定义“实例原型”的。